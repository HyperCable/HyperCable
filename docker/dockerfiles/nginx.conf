worker_processes  auto;
worker_rlimit_nofile 100000;
error_log /dev/stdout info;

env REDIS_HOST;
env REDIS_PORT;
env SAAS_REDIS_HOST;
env SAAS_REDIS_PORT;

events {
    multi_accept on;
    use epoll;
    worker_connections 4000;

}
http {
    init_worker_by_lua_block {
        local uuid = require 'resty.jit-uuid'
        uuid.seed()
    }
    resolver 127.0.0.11 ipv6=off;

    open_file_cache max=200000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    tcp_nopush on;
    tcp_nodelay on;
    reset_timedout_connection on;
    client_body_timeout 10;
    send_timeout 2;
    keepalive_timeout 30;
    keepalive_requests 100000;

    server {
        listen        8000;
        charset       utf-8;
        charset_types application/json;
        default_type  application/json;


        lua_code_cache on;
        lua_need_request_body on;
        real_ip_header X-Forwarded-For;
        # set_real_ip_from 0.0.0.0/0;

        location ~ /debug/mp/collect {

            if ($request_method ~* "(GET|POST)") {
                add_header "Access-Control-Allow-Origin"  *;
            }

            if ($request_method = OPTIONS ) {
                add_header "Access-Control-Allow-Origin"  *;
                add_header "Access-Control-Allow-Methods" "GET, POST, OPTIONS, HEAD";
                add_header "Access-Control-Allow-Headers" "Authorization, Origin, X-Requested-With, Content-Type, Accept";
                return 200;
            }

            content_by_lua '
                local jsonschema = require "jsonschema"
                -- todo require event name
                local validator = jsonschema.generate_validator({
                  type = "object",
                  properties = {
                    app_instance_id = { type = "string" },
                    user_id = { type = "string" },
                    user_properties = { type = "object" },
                    timestamp_micros = { type = "number" },
                    non_personalized_ads = { type = "boolean"},
                    events = { type = "array" }
                  },
                  required = {"client_id", "events"}
                })
                local cjson = require "cjson"
                local redis = require "resty.redis"
                local r     = redis:new()
                if (os.getenv("SAAS_REDIS_HOST") == nil or os.getenv("SAAS_REDIS_HOST") == "") then
                    ok, err = r:connect(os.getenv("REDIS_HOST"), os.getenv("REDIS_PORT")) 
                else
                    ok, err = r:connect(os.getenv("SAAS_REDIS_HOST"), os.getenv("SAAS_REDIS_PORT"))
                end

                if not ok then
                  ngx.say(cjson.encode({
                    status = "error", 
                    msg =  "failed to connect: " .. err
                    }
                   )
                  )
                  return
                end

                local result = {status="ok", msg=""}
                local query = ngx.req.get_uri_args()
                local post = ngx.req.get_body_data()

                local measurement_id = query["measurement_id"]
                local api_secret = query["api_secret"]

                -- check measurement_id
                if (measurement_id == "" or measurement_id == nil) then
                    result["msg"] = "measurement_id not present"
                    result["status"] = "error"
                    ngx.say(cjson.encode(result))
                    return
                end

                -- check api_secret
                if (api_secret == "" or api_secret == nil) then
                    result["msg"] = "api_secret not present"
                    result["status"] = "error"
                    ngx.say(cjson.encode(result))
                    return
                else
                    local site_uuid = string.match(ngx.var.request_uri, "/" .. "(" .. string.rep(".", 36) .. ")")
                    if (site_uuid == "" or site_uuid == nil ) then
                        result["msg"] = "site_uuid not present (e.g., /e63f4903-293c-408c-807f-63b49a2d7376/debug/mp/collect)"
                        result["status"] = "error"
                        ngx.say(cjson.encode(result))
                        return
                    else
                        if (r:get(api_secret) ~= site_uuid) then
                            result["msg"] = "api_secret is not correct"
                            result["status"] = "error"
                            ngx.say(cjson.encode(result))
                            return
                        end
                    end
                end

                -- check payload
                local valid_ok, valid_err = validator(cjson.decode(post))
                if not valid_ok then
                    result["msg"] = valid_err
                    result["status"] = "error"
                    ngx.say(cjson.encode(result))
                    return
                end

                r:set_keepalive()
                r = nil
                ngx.status  = ngx.HTTP_OK
                result["msg"] = "ok"
                return ngx.say(cjson.encode(result))
            ';

        }

        location ~ /mp/collect {
            if ($request_method ~* "(GET|POST)") {
                add_header "Access-Control-Allow-Origin"  *;
            }

            if ($request_method = OPTIONS ) {
                add_header "Access-Control-Allow-Origin"  *;
                add_header "Access-Control-Allow-Methods" "GET, POST, OPTIONS, HEAD";
                add_header "Access-Control-Allow-Headers" "Authorization, Origin, X-Requested-With, Content-Type, Accept";
                return 200;
            }

            content_by_lua '
                local uuid = require "resty.jit-uuid"
                local cjson = require "cjson"
                local redis = require "resty.redis"
                local r     = redis:new()
                local ok, err = r:connect(os.getenv("REDIS_HOST"), os.getenv("REDIS_PORT"))

                if not ok then
                  ngx.say(cjson.encode({
                    status = "error", 
                    msg =  "failed to connect: " .. err
                    }
                   )
                  )
                  return
                end

                local payload = {}

                local req = {}
                req["ip"] = ngx.var.remote_addr
                req["user_agent"] = ngx.var.http_user_agent
                req["x_forwarded_for"] = ngx.var.http_x_forwarded_for
                req["path"] = ngx.var.request_uri
                
                local query = ngx.req.get_uri_args()
                local post = ngx.req.get_body_data()
                local time = os.time()

                payload["class"] = "MpEventJob"
 
                payload["queue"] = "default"
                payload["jid"] = uuid()
                payload["args"] = {query, post, req}
                payload["retry"] = true
                payload["created_at"] = time
                payload["enqueued_at"] = time

                assert(r:lpush("queue:default", cjson.encode(payload)))
                r:set_keepalive()
                r = nil
                ngx.status  = ngx.HTTP_OK
                return ngx.exit(ngx.HTTP_OK)
            ';

        }

        location ~ /g/collect {
            if ($request_method ~* "(GET|POST)") {
                add_header "Access-Control-Allow-Origin"  *;
            }

            if ($request_method = OPTIONS ) {
                add_header "Access-Control-Allow-Origin"  *;
                add_header "Access-Control-Allow-Methods" "GET, POST, OPTIONS, HEAD";
                add_header "Access-Control-Allow-Headers" "Authorization, Origin, X-Requested-With, Content-Type, Accept";
                return 200;
            }

            content_by_lua '
                local uuid = require "resty.jit-uuid"
                local cjson = require "cjson"
                local redis = require "resty.redis"
                local r     = redis:new()
                local ok, err = r:connect(os.getenv("REDIS_HOST"), os.getenv("REDIS_PORT"))

                if not ok then
                  ngx.say(cjson.encode({
                    status = "error", 
                    msg =  "failed to connect: " .. err
                    }
                   )
                  )
                  return
                end

                local payload = {}

                local req = {}
                req["ip"] = ngx.var.remote_addr
                req["user_agent"] = ngx.var.http_user_agent
                req["x_forwarded_for"] = ngx.var.http_x_forwarded_for
                req["path"] = ngx.var.request_uri
                
                local query = ngx.req.get_uri_args()
                local post = ngx.req.get_body_data()
                local time = os.time()

                payload["class"] = "EventJob"
 
                payload["queue"] = "default"
                payload["jid"] = uuid()
                payload["args"] = {query, post, req}
                payload["retry"] = true
                payload["created_at"] = time
                payload["enqueued_at"] = time

                assert(r:lpush("queue:default", cjson.encode(payload)))
                r:set_keepalive()
                r = nil
                ngx.status  = ngx.HTTP_OK
                return ngx.exit(ngx.HTTP_OK)
            ';
        }
    }
}